// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: query.sql

package database

import (
	"context"
	"database/sql"
)

const cancelExpiredTransactions = `-- name: CancelExpiredTransactions :many
UPDATE transactions
SET status = 'canceled'
WHERE timestamp < ?
AND status = 'in_process'
RETURNING payment_id
`

func (q *Queries) CancelExpiredTransactions(ctx context.Context, timestamp int64) ([]string, error) {
	rows, err := q.db.QueryContext(ctx, cancelExpiredTransactions, timestamp)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []string
	for rows.Next() {
		var payment_id string
		if err := rows.Scan(&payment_id); err != nil {
			return nil, err
		}
		items = append(items, payment_id)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const createInvite = `-- name: CreateInvite :exec
INSERT INTO invites (
	code, used, user_id
) VALUES (
	?, ?, ?
)
`

type CreateInviteParams struct {
	Code   string
	Used   int64
	UserID int64
}

func (q *Queries) CreateInvite(ctx context.Context, arg CreateInviteParams) error {
	_, err := q.db.ExecContext(ctx, createInvite, arg.Code, arg.Used, arg.UserID)
	return err
}

const createService = `-- name: CreateService :one
INSERT INTO services (
	name, type, created_at, expires_at, prolong, prolong_price, user_id, location_id
) VALUES (
	?, ?, ?, ?, ?, ?, ?, ?
)
RETURNING id
`

type CreateServiceParams struct {
	Name         string
	Type         string
	CreatedAt    int64
	ExpiresAt    int64
	Prolong      int64
	ProlongPrice int64
	UserID       int64
	LocationID   int64
}

func (q *Queries) CreateService(ctx context.Context, arg CreateServiceParams) (int64, error) {
	row := q.db.QueryRowContext(ctx, createService,
		arg.Name,
		arg.Type,
		arg.CreatedAt,
		arg.ExpiresAt,
		arg.Prolong,
		arg.ProlongPrice,
		arg.UserID,
		arg.LocationID,
	)
	var id int64
	err := row.Scan(&id)
	return id, err
}

const createTransaction = `-- name: CreateTransaction :one
INSERT INTO transactions (
	payment_id, amount, status, timestamp, url, user_id
) VALUES (
	?, ?, ?, ?, ?, ?
)
RETURNING id
`

type CreateTransactionParams struct {
	PaymentID string
	Amount    int64
	Status    string
	Timestamp int64
	Url       string
	UserID    int64
}

func (q *Queries) CreateTransaction(ctx context.Context, arg CreateTransactionParams) (int64, error) {
	row := q.db.QueryRowContext(ctx, createTransaction,
		arg.PaymentID,
		arg.Amount,
		arg.Status,
		arg.Timestamp,
		arg.Url,
		arg.UserID,
	)
	var id int64
	err := row.Scan(&id)
	return id, err
}

const createUser = `-- name: CreateUser :one
INSERT INTO users (
	name, password_hash, balance, invites
) VALUES (
	?, ?, ?, ?
)
RETURNING id
`

type CreateUserParams struct {
	Name         string
	PasswordHash string
	Balance      int64
	Invites      int64
}

func (q *Queries) CreateUser(ctx context.Context, arg CreateUserParams) (int64, error) {
	row := q.db.QueryRowContext(ctx, createUser,
		arg.Name,
		arg.PasswordHash,
		arg.Balance,
		arg.Invites,
	)
	var id int64
	err := row.Scan(&id)
	return id, err
}

const deleteService = `-- name: DeleteService :exec
DELETE FROM services
WHERE id = ?
`

func (q *Queries) DeleteService(ctx context.Context, id int64) error {
	_, err := q.db.ExecContext(ctx, deleteService, id)
	return err
}

const getExpiredServices = `-- name: GetExpiredServices :many
SELECT services.id, services.name, services.type, services.created_at, services.expires_at, services.prolong, services.prolong_price, services.user_id, services.location_id, service_locations.address FROM services
JOIN service_locations ON service_locations.id = services.location_id
WHERE expires_at < ?
`

type GetExpiredServicesRow struct {
	ID           int64
	Name         string
	Type         string
	CreatedAt    int64
	ExpiresAt    int64
	Prolong      int64
	ProlongPrice int64
	UserID       int64
	LocationID   int64
	Address      string
}

func (q *Queries) GetExpiredServices(ctx context.Context, expiresAt int64) ([]GetExpiredServicesRow, error) {
	rows, err := q.db.QueryContext(ctx, getExpiredServices, expiresAt)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetExpiredServicesRow
	for rows.Next() {
		var i GetExpiredServicesRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Type,
			&i.CreatedAt,
			&i.ExpiresAt,
			&i.Prolong,
			&i.ProlongPrice,
			&i.UserID,
			&i.LocationID,
			&i.Address,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getInvite = `-- name: GetInvite :one
SELECT id, code, used, user_id FROM invites
WHERE code = ? LIMIT 1
`

func (q *Queries) GetInvite(ctx context.Context, code string) (Invite, error) {
	row := q.db.QueryRowContext(ctx, getInvite, code)
	var i Invite
	err := row.Scan(
		&i.ID,
		&i.Code,
		&i.Used,
		&i.UserID,
	)
	return i, err
}

const getLocation = `-- name: GetLocation :one
SELECT id, name, address, services FROM service_locations
WHERE services LIKE '%' || ? || '%'
AND name = ? LIMIT 1
`

type GetLocationParams struct {
	Column1 sql.NullString
	Name    string
}

func (q *Queries) GetLocation(ctx context.Context, arg GetLocationParams) (ServiceLocation, error) {
	row := q.db.QueryRowContext(ctx, getLocation, arg.Column1, arg.Name)
	var i ServiceLocation
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Address,
		&i.Services,
	)
	return i, err
}

const getPrice = `-- name: GetPrice :one
SELECT amount FROM service_prices
WHERE type = ?
`

func (q *Queries) GetPrice(ctx context.Context, type_ string) (int64, error) {
	row := q.db.QueryRowContext(ctx, getPrice, type_)
	var amount int64
	err := row.Scan(&amount)
	return amount, err
}

const getService = `-- name: GetService :one
SELECT
	services.id, services.name,
	services.expires_at, services.created_at,
	services.prolong, services.prolong_price,
	services.type,
	service_locations.name,
	service_locations.address
FROM services
JOIN service_locations ON service_locations.id = services.location_id
WHERE services.id = ? AND services.user_id = ?
`

type GetServiceParams struct {
	ID     int64
	UserID int64
}

type GetServiceRow struct {
	ID           int64
	Name         string
	ExpiresAt    int64
	CreatedAt    int64
	Prolong      int64
	ProlongPrice int64
	Type         string
	Name_2       string
	Address      string
}

func (q *Queries) GetService(ctx context.Context, arg GetServiceParams) (GetServiceRow, error) {
	row := q.db.QueryRowContext(ctx, getService, arg.ID, arg.UserID)
	var i GetServiceRow
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.ExpiresAt,
		&i.CreatedAt,
		&i.Prolong,
		&i.ProlongPrice,
		&i.Type,
		&i.Name_2,
		&i.Address,
	)
	return i, err
}

const getUser = `-- name: GetUser :one
SELECT id, name, password_hash, balance, invites FROM users
WHERE id = ? LIMIT 1
`

func (q *Queries) GetUser(ctx context.Context, id int64) (User, error) {
	row := q.db.QueryRowContext(ctx, getUser, id)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.PasswordHash,
		&i.Balance,
		&i.Invites,
	)
	return i, err
}

const getUserByName = `-- name: GetUserByName :one
SELECT id, name, password_hash, balance, invites FROM users
WHERE name = ? LIMIT 1
`

func (q *Queries) GetUserByName(ctx context.Context, name string) (User, error) {
	row := q.db.QueryRowContext(ctx, getUserByName, name)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.PasswordHash,
		&i.Balance,
		&i.Invites,
	)
	return i, err
}

const getUserInvites = `-- name: GetUserInvites :many
SELECT id, code, used, user_id FROM invites
WHERE user_id = ? AND used = FALSE
`

func (q *Queries) GetUserInvites(ctx context.Context, userID int64) ([]Invite, error) {
	rows, err := q.db.QueryContext(ctx, getUserInvites, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Invite
	for rows.Next() {
		var i Invite
		if err := rows.Scan(
			&i.ID,
			&i.Code,
			&i.Used,
			&i.UserID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listLocations = `-- name: ListLocations :many
SELECT name, services FROM service_locations
`

type ListLocationsRow struct {
	Name     string
	Services string
}

func (q *Queries) ListLocations(ctx context.Context) ([]ListLocationsRow, error) {
	rows, err := q.db.QueryContext(ctx, listLocations)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListLocationsRow
	for rows.Next() {
		var i ListLocationsRow
		if err := rows.Scan(&i.Name, &i.Services); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listTransactions = `-- name: ListTransactions :many
SELECT id, payment_id, amount, status, timestamp, url, user_id FROM transactions
WHERE user_id = ?
`

func (q *Queries) ListTransactions(ctx context.Context, userID int64) ([]Transaction, error) {
	rows, err := q.db.QueryContext(ctx, listTransactions, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Transaction
	for rows.Next() {
		var i Transaction
		if err := rows.Scan(
			&i.ID,
			&i.PaymentID,
			&i.Amount,
			&i.Status,
			&i.Timestamp,
			&i.Url,
			&i.UserID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listUserServices = `-- name: ListUserServices :many
SELECT
	services.id, services.name,
	services.expires_at, services.type,
	service_locations.name
FROM services
JOIN service_locations ON service_locations.id = services.location_id
WHERE services.user_id = ?
`

type ListUserServicesRow struct {
	ID        int64
	Name      string
	ExpiresAt int64
	Type      string
	Name_2    string
}

func (q *Queries) ListUserServices(ctx context.Context, userID int64) ([]ListUserServicesRow, error) {
	rows, err := q.db.QueryContext(ctx, listUserServices, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListUserServicesRow
	for rows.Next() {
		var i ListUserServicesRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.ExpiresAt,
			&i.Type,
			&i.Name_2,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const prolongService = `-- name: ProlongService :exec
UPDATE services
SET expires_at = ? + (expires_at - created_at)
WHERE id = ?
`

type ProlongServiceParams struct {
	ExpiresAt int64
	ID        int64
}

func (q *Queries) ProlongService(ctx context.Context, arg ProlongServiceParams) error {
	_, err := q.db.ExecContext(ctx, prolongService, arg.ExpiresAt, arg.ID)
	return err
}

const updateBalance = `-- name: UpdateBalance :exec
UPDATE users
SET balance = ?
WHERE id = ?
`

type UpdateBalanceParams struct {
	Balance int64
	ID      int64
}

func (q *Queries) UpdateBalance(ctx context.Context, arg UpdateBalanceParams) error {
	_, err := q.db.ExecContext(ctx, updateBalance, arg.Balance, arg.ID)
	return err
}

const updatePassword = `-- name: UpdatePassword :exec
UPDATE users
SET password_hash = ?
WHERE id = ?
`

type UpdatePasswordParams struct {
	PasswordHash string
	ID           int64
}

func (q *Queries) UpdatePassword(ctx context.Context, arg UpdatePasswordParams) error {
	_, err := q.db.ExecContext(ctx, updatePassword, arg.PasswordHash, arg.ID)
	return err
}

const updateTransaction = `-- name: UpdateTransaction :one
UPDATE transactions
SET status = ?
WHERE payment_id = ?
RETURNING user_id, amount
`

type UpdateTransactionParams struct {
	Status    string
	PaymentID string
}

type UpdateTransactionRow struct {
	UserID int64
	Amount int64
}

func (q *Queries) UpdateTransaction(ctx context.Context, arg UpdateTransactionParams) (UpdateTransactionRow, error) {
	row := q.db.QueryRowContext(ctx, updateTransaction, arg.Status, arg.PaymentID)
	var i UpdateTransactionRow
	err := row.Scan(&i.UserID, &i.Amount)
	return i, err
}

const updateUserInvites = `-- name: UpdateUserInvites :exec
UPDATE users
SET invites = invites - 1
WHERE id = ?
`

func (q *Queries) UpdateUserInvites(ctx context.Context, id int64) error {
	_, err := q.db.ExecContext(ctx, updateUserInvites, id)
	return err
}

const useInvite = `-- name: UseInvite :exec
UPDATE invites
SET used = TRUE
WHERE id = ?
`

func (q *Queries) UseInvite(ctx context.Context, id int64) error {
	_, err := q.db.ExecContext(ctx, useInvite, id)
	return err
}
